<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="Yosevu Kilonzo" name="author"><meta content="Yosevu&apos;s notes." name="description"><meta content="" name="keywords"><title>Yosevu's notes</title><link href="css/main.css" rel="stylesheet"><link href="css/a11y-dark.min.css" rel="stylesheet"></head><body><div class="container"><nav><a href="https://notes.yosevu.com/index.html">Index</a></nav><main><article><h1>4Clojure Exercises</h1><p>Annotated solutions to 4Clojure&rsquo;s Clojure problems.</p><h2>1. Nothing but the Truth</h2><p>This is a clojure form. Enter a value which will make the form evaluate to true.<pre><code class="clojure">&#40;defn nothing-but-truth &#91;&#93;
  &#40;= true true&#41;&#41;
</code></pre></p><h2>2. Simple Math</h2><p>If you are not familiar with <a href='http://en.wikipedia.org/wiki/Polish_notation'>polish notation</a>, simple arithmetic might seem confusing.<pre><code class="clojure">&#40;=
  &#40;- 10 &#40;&#42; 2 3&#41;&#41;4&#41;
</code></pre></p><h2>3. Intro to strings</h2><p>Clojure strings are Java strings. This means that you can use any of the Java string methods on Clojure strings.<pre><code class="clojure">&#40;= &quot;HELLO WORLD&quot;
    &#40;.toUpperCase &quot;hello world&quot;&#41;&#41;
</code></pre></p><h2>4. Intro to lists</h2><p>Lists can be constructed with either a function or a quoted form.<pre><code class="clojure">&#40;= &#40;list :a :b :c&#41;
   '&#40;:a :b :c&#41;&#41;
</code></pre></p><h2>5. Lists: conj</h2><p>When operating on a list, the conj function will return a new list with one or more items &ldquo;added&rdquo; to the front.<pre><code class="clojure">&#40;= '&#40;1 2 3 4&#41;
    &#40;conj '&#40;2 3 4&#41;&#41;&#41;

&#40;= '&#40;1 2 3 4&#41;
    &#40;conj '&#40;3 4&#41; 2 1&#41;&#41;
</code></pre></p><h2>6. Intro to vectors</h2><p>Vectors can be constructed several ways. You can compare them with lists.<pre><code class="clojure">&#40;= &#91;:a :b :c&#93;
    &#40;list :a :b :c&#41;
    &#40;vec '&#40;:a :b :c&#41;&#41;
    &#40;vector :a :b :c&#41;&#41;
</code></pre></p><h2>7. Vectors: conj</h2><p>When operating on a Vector, the conj function will return a new vector with one or more items &ldquo;added&rdquo; to the end.<pre><code class="clojure">&#40;= &#91;1 2 3 4&#93;
    &#40;conj &#91;1 2 3&#93; 4&#41;&#41;

&#40;= &#91;1 2 3 4&#93;
    &#40;conj &#91;1 2&#93; 3 4&#41;&#41;
</code></pre></p><p><code>conj</code> is a clipping, (an apocope) of conjoin.</p><h2>8. Intro to sets</h2><p>Sets are collections of unique values.<pre><code class="clojure">&#40;= #{:a :b :c :d}
    &#40;set '&#40;:a :a :b :c :c :c :c :d :d&#41;&#41;&#41;
&#40;= #{:a :b :c :d}
    &#40;clojure.set/union #{:a :b :c} #{:b :c :d}&#41;&#41;
</code></pre></p><p>&ldquo;In <a href='https://notes.yosevu.com/set-theory.html.md'>set theory</a>, the union of a collection of sets is the set of all elements in the collection.&rdquo; - <a href='https://en.wikipedia.org/wiki/Union_(set_theory'>Union (set theory), Wikipedia</a>)</p><p>In the second example above, there are two sets in the collection.</p><ol><li><code>#{:a :b :c}</code></li><li><code>#{:b :c :d}</code></li></ol><p>The union of the sets A and B (A âˆª B) is the set <code>#{:a :b :c :d}</code>.</p><p><code>=</code> returns <code>true</code> when called as a unary function (with one argument): <code>&#40;= 1&#41;</code>.</p><h2>9. Sets: conj</h2><p>When operating on a set, the conj function returns a new set with one or more keys &ldquo;added&rdquo;.<pre><code class="clojure">&#40;= #{1 2 3 4}
    &#40;conj #{1 4 3} 2&#41;&#41;
</code></pre></p><h2>10. Intro to maps</h2><p>Maps store key-value pairs. Both maps and keywords can be used as lookup functions. Commas can be used to make maps more readable, but they are not required.<pre><code class="clojure">&#40;= 20
    &#40;&#40;hash-map :a 10 :b 20 :c 30&#41; :b&#41;&#41;

&#40;= 20
    &#40;:b {:a 10 :b 20 :c 30}&#41;&#41;
</code></pre></p><h2>11. Maps: conj</h2><p>When operating on a map, the conj function returns a new map with one or more key-value pairs &ldquo;added&rdquo;.<pre><code class="clojure">&#40;= {:a 1, :b 2, :c 3}
   &#40;conj {:a 1} {:b 2} &#91;:c 3&#93;&#41;&#41;
</code></pre></p><h2>12. Intro to Sequences</h2><p>All Clojure collections support sequencing. You can operate on sequences with functions like first, second, and last.<pre><code class="clojure">&#40;= 3 &#40;first '&#40;3 2 1&#41;&#41;&#41;
&#40;= 3 &#40;second &#91;2 3 4&#93;&#41;&#41;
&#40;= 3 &#40;last &#40;list 1 2 3&#41;&#41;&#41;
</code></pre></p><h2>13. Sequences: rest</h2><pre><code class="clojure">&#40;= &#91;20 30 40&#93;
    &#40;rest &#91;10 20 30 40&#93;&#41;&#41;
</code></pre><p><code>rest</code> returns a sequence. <code>&#91;20 30 40&#93;</code> and <code>'&#40;20 30 40&#41;</code> are equal because they are the same sequence.</p><h2>14. Intro to Functions</h2><p>Clojure has many different ways to create functions.</p><pre><code class="clojure">&#40;= 8
    &#40;&#40;fn add-five &#91;x&#93; &#40;+ x 5&#41;&#41; 3&#41;&#41;

&#40;= 8
    &#40;&#40;fn &#91;x&#93; &#40;+ x 5&#41;&#41; 3&#41;&#41;

&#40;= 8
    &#40;#&#40;+ % 5&#41; 3&#41;&#41;

&#40;= 8
    &#40;&#40;partial + 5&#41; 3&#41;&#41;
</code></pre><p>There is also <code>defn</code>:<pre><code class="clojure">&#40;defn add-five
  &quot;Add five to a number.&quot;
  &#91;x&#93;
  &#40;+ x 5&#41;&#41;

&#40;= 8
    &#40;add-five 3&#41;&#41;
</code></pre></p><h2>15. Double Down</h2><p>Write a function which doubles a number.<pre><code class="clojure">&#40;defn double-down &#91;n&#93;
  &#40;+ n n&#41;&#41; ; &#40;&#42; n 2&#41;

&#40;= &#40;double-down 2&#41; 4&#41;
&#40;= &#40;double-down 3&#41; 6&#41;
&#40;= &#40;double-down 11&#41; 22&#41;
&#40;= &#40;double-down 7&#41; 14&#41;
</code></pre></p><h2>16. Hello World</h2><p><strong>Function</strong><pre><code class="clojure">&#40;defn hello-world
  &quot;Hello, World!&quot;
  &#91;name&#93;
  &#40;str &quot;Hello, &quot; name &quot;!&quot;&#41;&#41;

&#40;= &#40;hello-world &quot;Dave&quot;&#41; &quot;Hello, Dave!&quot;&#41;
&#40;= &#40;hello-world &quot;Jenn&quot;&#41;, &quot;Hello, Jenn!&quot;&#41;
&#40;= &#40;hello-world &quot;Rhea&quot;&#41;, &quot;Hello, Rhea!&quot;&#41;
</code></pre></p><p><strong>Anonymous function</strong><pre><code class="clojure">  &#40;fn &#91;name&#93; &#40;str &quot;Hello, &quot; name &quot;!&quot;&#41;&#41;
</code></pre></p><p><strong>Shorthand anonymous function</strong><pre><code class="clojure">#&#40;str &quot;Hello, &quot; % &quot;!&quot;&#41;
</code></pre></p><h2>17. Sequences: map</h2><pre><code class="clojure">&#40;= '&#40;6 7 8&#41;
    &#40;map #&#40;+ % 5&#41; '&#40;1 2 3&#41;&#41;&#41;
</code></pre><p><code>map</code> is an essential <a href='https://notes.yosevu.com/functional-thinking.html'>tool for thinking functionally</a>. It takes two arguments: a function (f) and a sequence (s). Map returns a new sequence consisting of the result of applying f to each item of s. Do not confuse the map function with the map data structure.</p><h2>18. Sequences: filter</h2><pre><code class="clojure">&#40;= '&#40;6 7&#41;
    &#40;filter #&#40;&gt; % 5&#41; '&#40;3 4 5 6 7&#41;&#41;&#41;
</code></pre><p><code>filter</code> is an essential <a href='https://notes.yosevu.com/functional-thinking.html'>tool for thinking functionally</a>. It takes two arguments: a predicate function (f) and a sequence (s). Filter returns a new sequence consisting of all the items of s for which (f item) returns true.</p><h2>19. Last element</h2><p>Write a function which returns the last element in a sequence.</p><p>Special Restrictions: last</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn last-element &#91;s&#93;
  &#40;nth s &#40;- &#40;count s&#41; 1&#41;&#41;&#41;
</code></pre></p><p><strong>Other solutions</strong><pre><code class="clojure">&#40;defn last-element &#91;s&#93;
  &#40;nth s &#40;dec &#40;count s&#41;&#41;&#41;&#41;
</code></pre></p><h2>20. Penultimate element</h2><p>Write a function which returns the second to last element from a sequence.</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn penultimate-element &#91;s&#93;
  &#40;nth s &#40;- &#40;count s&#41; 2&#41;&#41;&#41;
</code></pre></p><p><strong>Other solutions</strong><pre><code class="clojure">&#40;defn penultimate-element &#91;s&#93;
  &#40;comp second reverse&#41;&#41;
</code></pre></p><h2>21. Nth element</h2><p>Write a function which returns the Nth element from a sequence.</p><p>Special Restrictions: nth</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn nth-element &#91;s index&#93;
  &#40;get &#40;vec s&#41; index&#41;&#41;
</code></pre></p><p><strong>Other solutions</strong><pre><code class="clojure">&#40;defn nth-element &#91;coll n&#93;
  &#40;first &#40;drop n coll&#41;&#41;&#41;
</code></pre></p><h2>22. Count a sequence</h2><p>Write a function which returns the total number of elements in a sequence.</p><p>Special Restrictions: count</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn count-a-sequence &#91;s&#93;
  &#40;reduce &#40;fn &#91;total item&#93;
            &#40;inc total&#41;&#41; 0 s&#41;&#41;
</code></pre></p><p><strong>Other solutions</strong><pre><code class="clojure">&#40;defn count-a-sequence &#91;s&#93;
  &#40;reduce + &#40;map &#40;constantly 1&#41; s&#41;&#41;&#41;
</code></pre></p><h2>23. Reverse a sequence</h2><p>Write a function which reverses a sequence.</p><p>Special Restrictions: reverse rseq</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn reverse-a-sequence &#91;s&#93;&#41;
</code></pre></p><h2>24. Sum it all up</h2><p>Write a function which returns the sum of a sequence of numbers.</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn sum-it-all-up &#91;nums&#93;
  &#40;reduce + nums&#41;&#41;
</code></pre></p><h2>25. Find the odd numbers</h2><p>Write a function which returns only the odd numbers from a sequence.<pre><code class="clojure">&#40;defn find-the-odd-numbers &#91;nums&#93;
  &#40;filter odd? nums&#41;&#41;
</code></pre></p><h2>26. Fibonacci sequence</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-17 Sat]</span></span></em></p><p><strong>Solution</strong><pre><code class="clojure">&#40;defn fib
  &quot;Generate a lazy fibonacci sequence&quot;
  &#40;&#91;&#93;
    &#40;fib 1 1&#41;&#41;
  &#40;&#91;a b&#93;
    &#40;lazy-seq &#40;cons a &#40;fib b &#40;+ a b&#41;&#41;&#41;&#41;&#41;&#41;

&#40;defn fibonacci-sequence
  &quot;Write a function which returns the first X fibonacci numbers.&quot;
  &#91;x&#93;
  &#40;take x &#40;fib&#41;&#41;&#41;
</code></pre></p><p><strong>4Clojure Solution</strong><pre><code class="clojure">#&#40;take % &#40;&#40;fn fib
              &#40;&#91;&#93;
              &#40;fib 1 1&#41;&#41;
              &#40;&#91;a b&#93;
              &#40;lazy-seq &#40;cons a &#40;fib b &#40;+ a b&#41;&#41;&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest test-fibonacci-sequence
  &#40;is &#40;= &#40;fibonacci-sequence 3&#41; '&#40;1 1 2&#41;&#41;&#41;
  &#40;is &#40;= &#40;fibonacci-sequence 6&#41; '&#40;1 1 2 3 5 8&#41;&#41;&#41;
  &#40;is &#40;= &#40;fibonacci-sequence 8&#41; '&#40;1 1 2 3 5 8 13 21&#41;&#41;&#41;&#41;
</code></pre></p><p><strong>Notes</strong></p><ul><li>The <a href='https://clojure.org/reference/special_forms#fn'>anonymous function special</a> form can take a symbol name, which is can be used to reference the function recursively.</li><li>Each arity is a list in multi-arity function definitions.</li></ul><p><strong>Questions</strong></p><ul><li>How is a the base case resolved in a lazy sequence?    <code>&#40;cons 1 &#40;cons 1 &#40;cons 2 &#40;cons 3 ...&#41;&#41;&#41;</code></li></ul><h2>27. Palindrome detector</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-14 Wed]</span></span></em><pre><code class="clojure">&#40;defn palindrome-detector
  &quot;Write a function which returns true if the given sequence is a palindrome.&quot;
  &#91;x&#93;
  &#40;= &#40;seq x&#41; &#40;reverse &#40;seq x&#41;&#41;&#41;&#41;
</code></pre></p><p><strong>Short version</strong><pre><code class="clojure">#&#40;= &#40;seq %&#41; &#40;reverse &#40;seq %&#41;&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest palindrome-detector
  &#40;is &#40;false? &#40;palindrome-detector '&#40;1 2 3 4 5&#41;&#41;&#41;&#41;
  &#40;is &#40;true? &#40;palindrome-detector &quot;racecar&quot;&#41;&#41;&#41;
  &#40;is &#40;true? &#40;palindrome-detector &#91;:foo :bar :foo&#93;&#41;&#41;&#41;
  &#40;is &#40;true? &#40;palindrome-detector '&#40;1 1 3 3 1 1&#41;&#41;&#41;&#41;
  &#40;is &#40;false? &#40;palindrome-detector '&#40;:a :b :c&#41;&#41;&#41;&#41;&#41;
</code></pre></p><h2>28. Flatten a sequence</h2><p>Write a function which flattens a sequence.</p><p>Special Restrictions: flatten</p><p><strong>Iteration 1</strong><pre><code class="clojure">&#40;defn my-flatten &#91;coll&#93;
  &#40;seq &#40;reduce &#40;fn &#91;result item&#93;
            &#40;if &#40;coll? item&#41;
                &#40;into result &#40;my-flatten &#40;first &#40;list item&#41;&#41;&#41;&#41;
                &#40;conj result item&#41;&#41;&#41;
          &#91;&#93;
          coll&#41;&#41;&#41;
</code></pre></p><p><strong>Iteration 2</strong><pre><code class="clojure">&#40;defn my-flatten &#91;item&#93;
  &#40;cond
    &#40;coll? item&#41; &#40;mapcat my-flatten item&#41;
    :else &#91;item&#93;&#41;&#41;
</code></pre></p><h2>36. Let it be</h2><p>Can you bind x, y, and z so that these are all true?<pre><code class="clojure">&#40;deftest let-it-be
  &#40;is &#40;= 10 &#40;let &#91;x 7 y 3 z 1&#93; &#40;+ x y&#41;&#41;&#41;&#41;
  &#40;is &#40;=  4 &#40;let &#91;x 7 y 3 z 1&#93; &#40;+ y z&#41;&#41;&#41;&#41;
  &#40;is &#40;=  1 &#40;let &#91;x 7 y 3 z 1&#93; z&#41;&#41;&#41;&#41;
</code></pre></p><p><code>let</code> binds pairs of symbol-value pairs in a vector.</p><h2>37. Regular expressions</h2><p>Regex patterns are supported with a special reader macro.<pre><code class="clojure">&#40;deftest reglar-expressions
  &#40;is &#40;= &quot;ABC&quot; &#40;apply str &#40;re-seq #&quot;&#91;A-Z&#93;+&quot; &quot;bA1B3Ce&quot;&#41;&#41;&#41;&#41;&#41;
</code></pre></p><p><code>re-seq</code> returns a sequence of matches in a string.</p><h2>38. Maximum value</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-10 Sat]</span></span></em><pre><code class="clojure">&#40;defn maximum-value
  &quot;Takes a variable number of parameters and returns the maximum value.&quot;
  &#91;&amp; vals&#93;
  &#40;reduce #&#40;if &#40;&gt; %1 %2&#41; %1 %2&#41; vals&#41;&#41;
</code></pre></p><p><strong>Tests</strong></p><pre><code>&#40;deftest maximum-value
  &#40;is &#40;= &#40;maximum-value 1 8 3 4&#41; 8&#41;&#41;&#41;</code></pre><p><code>reduce</code> is an essential <a href='https://notes.yosevu.com/functional-thinking.html'>tool for thinking functionally</a>. It has two arities. The first takes a function and a collection and the second takes a function, an initial value, and a collection. The function passed to reduce has to parameters, the result and the current item in the collection. If there is an initial value argument, it is passed as the result parameter. If not, the first item of the collection is passed by default.</p><h2>39. Interleave two seqs</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-11 Sun]</span></span></em><pre><code class="clojure">&#40;defn interleave-two-seqs
  &quot;Write a function which takes two sequences and returns the first item from each,
    then the second item from each, then the third, etc.&quot;
  &#91;coll-a coll-b&#93;
  &#40;mapcat #&#40;conj &#91;&#93; %1 %2&#41; coll-a coll-b&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest interleave-two-seqs
  &#40;is &#40;= &#40;interleave-two-seqs&#91;1 2 3&#93; &#91;:a :b :c&#93;&#41; '&#40;1 :a 2 :b 3 :c&#41;&#41;&#41;
  &#40;is &#40;= &#40;interleave-two-seqs &#91;1 2&#93; &#91;3 4 5 6&#93;&#41; '&#40;1 3 2 4&#41;&#41;&#41;
  &#40;is &#40;= &#40;interleave-two-seqs &#91;1 2 3 4&#93; &#91;5&#93;&#41; &#91;1 5&#93;&#41;&#41;
  &#40;is &#40;= &#40;interleave-two-seqs &#91;30 20&#93; &#91;25 15&#93;&#41; &#91;30 25 20 15&#93;&#41;&#41;&#41;
</code></pre></p><p><code>mapcat</code> is an essential <a href='https://notes.yosevu.com/functional-thinking.html'>tool for thinking functionally</a>. It concatenates the results applying a map function to a set of collections.</p><h2>40. Interpose a seq</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-12 Mon]</span></span></em> <a href='https://notes.yosevu.com/learning-journal.html'>Today I learned</a> that nested <code>#&#40;&#41;</code> are not allowed.<pre><code class="clojure">&#40;defn interpose-a-seq
  &quot;Write a function which separates the items of a sequence by an arbitrary value.&quot;
  &#91;sep coll&#93;
  &#40;drop-last &#40;reduce #&#40;conj %1 %2 sep&#41; &#91;&#93; coll&#41;&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest interpose-a-seq
  &#40;is &#40;= &#40;interpose-a-seq 0 &#91;1 2 3&#93;&#41; &#91;1 0 2 0 3&#93;&#41;&#41;
  &#40;is &#40;= &#40;apply str &#40;interpose-a-seq &quot;, &quot; &#91;&quot;one&quot; &quot;two&quot; &quot;three&quot;&#93;&#41;&#41; &quot;one, two, three&quot;&#41;&#41;
  &#40;is &#40;= &#40;interpose-a-seq :z &#91;:a :b :c :d&#93;&#41; &#91;:a :z :b :z :c :z :d&#93;&#41;&#41;&#41;
</code></pre></p><h2>41. Drop every nth item</h2><p><em><span class="timestamp-wrapper"><span class="timestamp">[2020-10-13 Tue]</span></span></em><pre><code class="clojure">&#40;defn drop-every-nth-item
  &quot;Write a function which drops every Nth item from a sequence.&quot;
  &#91;n coll&#93;
  &#40;apply concat &#40;partition-all &#40;dec n&#41; n coll&#41;&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest drop-every-nth-item
  &#40;is &#40;= &#40;drop-every-nth-item 3 &#91;1 2 3 4 5 6 7 8&#93;&#41; &#91;1 2 4 5 7 8&#93;&#41;&#41;
  &#40;is &#40;= &#40;drop-every-nth-item 2 &#91;:a :b :c :d :e :f&#93;&#41; &#91;:a :c :e&#93;&#41;&#41;
  &#40;is &#40;= &#40;drop-every-nth-item 4 &#91;1 2 3 4 5 6&#93;&#41; &#91;1 2 3 5 6&#93;&#41;&#41;&#41;
</code></pre></p><p><code>partition</code> is an essential <a href='https://notes.yosevu.com/functional-thinking.html'>tool for thinking functionally</a>. It allows you to divide a list of items into a collection of smaller lists. The step option lets you skip items in the list that you do not want to include in the smaller lists.</p><p><strong>Note</strong>: I flipped the parameters in order to pass the data as the last argument. This simplifies function composition as described in <a href='http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda'>Introducing Ramda</a>.</p><h2>42. Factorial fun</h2><pre><code class="clojure">&#40;defn factorial-fun
  &quot;Write a function which calculates factorials.&quot;
  &#91;n&#93;
  &#40;reduce &#42; &#40;range 1 &#40;inc n&#41;&#41;&#41;&#41;
</code></pre><p><strong>Short solution</strong><pre><code class="clojure">#&#40;reduce &#42; &#40;range 1 &#40;inc %&#41;&#41;&#41;
</code></pre></p><p><strong>Tests</strong><pre><code class="clojure">&#40;deftest factorial-fun
  &#40;is &#40;= &#40;factorial-fun 1&#41; 1&#41;&#41;
  &#40;is &#40;= &#40;factorial-fun 3&#41; 6&#41;&#41;
  &#40;is &#40;= &#40;factorial-fun 5&#41; 120&#41;&#41;
  &#40;is &#40;= &#40;factorial-fun 8&#41; 40320&#41;&#41;&#41;
</code></pre></p><h2>43.</h2><p>Apply cf. unapply Packs vs. unpacks a value</p><p><a href="https://clojure.org/guides/learn/functions#_variadic_functions">https://clojure.org/guides/learn/functions#_variadic_functions</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max</a></p><h2>64. Intro to reduce</h2><pre><code class="clojure">&#40;deftest intro-to-reduce
  &#40;is &#40;= 15 &#40;reduce + &#91;1 2 3 4 5&#93;&#41;&#41;&#41;
  &#40;is &#40;=  0 &#40;reduce + &#91;&#93;&#41;&#41;&#41;
  &#40;is &#40;=  6 &#40;reduce + 1 &#91;2 3&#93;&#41;&#41;&#41;&#41;
</code></pre></article><aside><h4>Links to this note</h4><ul><li><a href="https://notes.yosevu.com/functional-thinking">Functional Thinking</a></li><li><a href="https://notes.yosevu.com/learning-journal">Learning Journal</a></li></ul></aside></main><script src="js/highlight.min.js"></script><script>hljs.highlightAll()</script></div></body></html>